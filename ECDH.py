# -*- coding: utf-8 -*-
"""ECDH.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KZZ7i05AcVpXXrUDt1eGtYRFfNM7RG76
"""

# Communication using ECDH

import hashlib
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization, padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

class ECDH:
    def __init__(self):
        self.private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())
        self.public_key = self.private_key.public_key()
        self.shared_key = None

    def get_public_key_bytes(self):
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )

    def load_peer_public_key(self, peer_public_key_bytes):
        self.peer_public_key = serialization.load_pem_public_key(peer_public_key_bytes, backend=default_backend())

    def derive_shared_secret(self):
        shared_secret = self.private_key.exchange(ec.ECDH(), self.peer_public_key)
        self.shared_key = hashlib.sha256(shared_secret).digest()

    def encrypt(self, message):
        if self.shared_key is None:
            raise ValueError("Shared key is not derived yet. Call derive_shared_secret() first.")

        padder = padding.PKCS7(algorithms.AES.block_size).padder()
        padded_message = padder.update(message) + padder.finalize()

        iv = os.urandom(16)
        cipher = Cipher(algorithms.AES(self.shared_key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(padded_message) + encryptor.finalize()

        return iv, ciphertext

    def decrypt(self, iv, ciphertext):
        if self.shared_key is None:
            raise ValueError("Shared key is not derived yet. Call derive_shared_secret() first.")

        cipher = Cipher(algorithms.AES(self.shared_key), modes.CBC(iv), backend=default_backend())
        decryptor = cipher.decryptor()
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()

        return plaintext

# Example usage
if __name__ == "__main__":
    # Initialize ECDH instances for both Alice and Bob
    alice = ECDH()
    bob = ECDH()

    # Exchange public keys
    alice_public_key_bytes = alice.get_public_key_bytes()
    bob_public_key_bytes = bob.get_public_key_bytes()

    alice.load_peer_public_key(bob_public_key_bytes)
    bob.load_peer_public_key(alice_public_key_bytes)

    # Derive shared secrets
    alice.derive_shared_secret()
    bob.derive_shared_secret()

    # Encrypt and decrypt a message using the shared secret
    message = b'Hello, Bob!'
    iv, ciphertext = alice.encrypt(message)
    decrypted_message = bob.decrypt(iv, ciphertext)

    # Verify that the decrypted message is the same as the original message
    assert decrypted_message == message

    print(f"Original message: {message}")
    print(f"Encrypted message: {ciphertext}")
    print(f"Decrypted message: {decrypted_message}")

!pip install cryptography

# prompt: ECDH key exchange algorithm

import hashlib
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec

# Generate Alice's private key
alice_private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())

# Generate Alice's public key
alice_public_key = alice_private_key.public_key()

# Generate Bob's private key
bob_private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())

# Generate Bob's public key
bob_public_key = bob_private_key.public_key()

# Alice and Bob exchange public keys

# Alice computes the shared secret
shared_secret_alice = alice_private_key.exchange(ec.ECDH(), bob_public_key)

# Bob computes the shared secret
shared_secret_bob = bob_private_key.exchange(ec.ECDH(), alice_public_key)

# Verify that the shared secrets are the same
assert shared_secret_alice == shared_secret_bob

# Hash the shared secret to use it as a key
key = hashlib.sha256(shared_secret_alice).digest()
key2 = hashlib.sha256(shared_secret_bob).digest()
print(key)
print(key2)

