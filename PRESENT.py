# -*- coding: utf-8 -*-
"""PRESENT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rE6fQSbNhtYpyWPRDLg9e291NiUKQ7Qx
"""

import base64

# Read the image file
with open("/content/apple.jpeg", "rb") as image_file:
    # Encode the image in Base64 format
    base64_image = base64.b64encode(image_file.read())

# Save the Base64 encoded data to a text file
with open("image_base64.txt", "w") as text_file:
    text_file.write(base64_image.decode("utf-8"))

print("Image converted to text data and saved as image_base64.txt")

import struct
import time

start_time = time.time()

# Define the SBox
S = [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]
# Define the inverse SBox
invS = [0x5, 0xe, 0xf, 0x8, 0xC, 0x1, 0x2, 0xD, 0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]
# Define the permutation table
P = [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
     4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
     8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
     12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]

def from_hex_string_to_bytes(block):
    bytes_list = []
    for i in range(8):
        nibble1 = int(block[2*i], 16)
        nibble2 = int(block[2*i+1], 16)
        bytes_list.append((nibble1 << 4) | nibble2)
    return bytes_list

def from_bytes_to_long(bytes_list):
    result = 0
    for byte in bytes_list:
        result = (result << 8) | byte
    return result

def from_hex_string_to_long(block):
    return int(block, 16)

def from_long_to_bytes(block):
    bytes_list = []
    for i in range(8):
        byte = (block >> (7 - i) * 8) & 0xFF
        bytes_list.append(byte)
    return bytes_list

def from_long_to_hex_string(block):
    return f"{block:016x}"

def sbox(input_byte):
    return S[input_byte]

def inverse_sbox(input_byte):
    return invS[input_byte]

def permute(source):
    permutation = 0
    for i in range(64):
        bit = (source >> (63 - i)) & 0x1
        permutation |= bit << (63 - P[i])
    return permutation

def inverse_permute(source):
    permutation = 0
    for i in range(64):
        bit = (source >> (63 - P[i])) & 0x1
        permutation = (permutation << 1) | bit
    return permutation

def get_key_low(key):
    key_low = int(key[16:20], 16)
    return key_low

def generate_subkeys(key):
    key_high = from_hex_string_to_long(key[:16])
    key_low = get_key_low(key)
    subkeys = [0] * 32
    subkeys[0] = key_high
    for i in range(1, 32):
        temp1, temp2 = key_high, key_low
        key_high = ((key_high << 61) | (temp2 << 45) | (temp1 >> 19)) & 0xFFFFFFFFFFFFFFFF
        key_low = (temp1 >> 3) & 0xFFFF
        temp = sbox(key_high >> 60)
        key_high = (key_high & 0x0FFFFFFFFFFFFFFF) | (temp << 60)
        key_low ^= ((i & 0x01) << 15)
        key_high ^= (i >> 1)
        subkeys[i] = key_high
    return subkeys

def encrypt_block(block, subkeys):
    state = block
    for i in range(31):
        state ^= subkeys[i]
        state_bytes = from_long_to_bytes(state)
        state_bytes = [sbox(byte >> 4) << 4 | sbox(byte & 0xF) for byte in state_bytes]
        state = permute(from_bytes_to_long(state_bytes))
    state ^= subkeys[31]
    return state

def decrypt_block(block, subkeys):
    state = block
    for i in range(31):
        state ^= subkeys[31 - i]
        state = inverse_permute(state)
        state_bytes = from_long_to_bytes(state)
        state_bytes = [inverse_sbox(byte >> 4) << 4 | inverse_sbox(byte & 0xF) for byte in state_bytes]
        state = from_bytes_to_long(state_bytes)
    state ^= subkeys[0]
    return state

def encrypt_text(plaintext, key):
    # Pad the plaintext if its length is not a multiple of 16
    padded_plaintext = plaintext.ljust((len(plaintext) + 15) // 16 * 16, '\x00')
    subkeys = generate_subkeys(key)
    encrypted_blocks = []
    for i in range(0, len(padded_plaintext), 16):
        block = from_hex_string_to_long(padded_plaintext[i:i+16])
        encrypted_block = encrypt_block(block, subkeys)
        encrypted_blocks.append(from_long_to_hex_string(encrypted_block))
    return ''.join(encrypted_blocks)

def decrypt_text(ciphertext, key):
    subkeys = generate_subkeys(key)
    decrypted_blocks = []
    for i in range(0, len(ciphertext), 16):
        block = from_hex_string_to_long(ciphertext[i:i+16])
        decrypted_block = decrypt_block(block, subkeys)
        decrypted_blocks.append(from_long_to_hex_string(decrypted_block))
    return ''.join(decrypted_blocks)

def text_to_hex(text):
    # Convert each character to its ASCII value and then to hex
    hex_string = ''.join([f"{ord(c):02x}" for c in text])

    # Ensure the hex string is padded to a multiple of 16 characters
    while len(hex_string) % 16 != 0:
        hex_string += '00'  # Pad with zeros if necessary

    return hex_string

def hex_to_text(hex_string):
    # Convert the hex string back to ASCII characters
    bytes_object = bytes.fromhex(hex_string)
    text = ''
    for byte in bytes_object:
        if 32 <= byte <= 126:  # ASCII printable characters range
            text += chr(byte)
        else:
            break  # Stop appending if non-printable character is encountered
    return text

with open("image_base64_01.txt", "r") as file:
    plaintext = file.read()

text = text_to_hex(plaintext)

key = "3e7a1f4b8c9d6e2f10b7"

ciphertext = encrypt_text(text, key)
with open("cipher_hex_01.txt", "w") as file:
    file.write(ciphertext)

# decrypted_hex = decrypt_text(ciphertext, key)

# decrypted_text = hex_to_text(decrypted_hex)
# with open("decipher_text.txt", "w") as file:
#     file.write(decrypted_text)


end_time = time.time()
elapsed_time = end_time - start_time
print(f"Elapsed time: {elapsed_time:.2f} seconds")

