# -*- coding: utf-8 -*-
"""ECC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CDa04PWRiDbuif8F4dDCui_NNPkqt0lS
"""

from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

class ECC:
    def __init__(self):
        self.private_key = None
        self.public_key = None

    def generate_keys(self):
        self.private_key = ec.generate_private_key(ec.SECP256R1())
        self.public_key = self.private_key.public_key()

    def serialize_public_key(self):
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )

    @staticmethod
    def deserialize_public_key(public_key_bytes):
        return serialization.load_pem_public_key(public_key_bytes)

    def derive_shared_secret(self, peer_public_key):
        shared_secret = self.private_key.exchange(ec.ECDH(), peer_public_key)
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'handshake data'
        ).derive(shared_secret)
        return derived_key

    @staticmethod
    def encrypt(derived_key, plaintext):
        iv = os.urandom(12)
        cipher = Cipher(algorithms.AES(derived_key), modes.GCM(iv))
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        return iv, ciphertext, encryptor.tag

    @staticmethod
    def decrypt(derived_key, iv, ciphertext, tag):
        cipher = Cipher(algorithms.AES(derived_key), modes.GCM(iv, tag))
        decryptor = cipher.decryptor()
        decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()
        return decrypted_data

# Example usage
if __name__ == "__main__":
    # Initialize ECC instances for both parties
    ecc_a = ECC()
    ecc_b = ECC()

    # Generate keys for both parties
    ecc_a.generate_keys()
    ecc_b.generate_keys()

    # Serialize and deserialize public keys for transmission
    public_key_a_bytes = ecc_a.serialize_public_key()
    public_key_b_bytes = ecc_b.serialize_public_key()
    public_key_a = ECC.deserialize_public_key(public_key_a_bytes)
    public_key_b = ECC.deserialize_public_key(public_key_b_bytes)

    # Derive shared secrets
    shared_secret_a = ecc_a.derive_shared_secret(public_key_b)
    shared_secret_b = ecc_b.derive_shared_secret(public_key_a)

    # Encrypt and decrypt a message
    message = b"This is a secret message"
    iv, ciphertext, tag = ECC.encrypt(shared_secret_a, message)
    decrypted_message = ECC.decrypt(shared_secret_b, iv, ciphertext, tag)

    print("Original message:", message)
    print("Encrypted message:", ciphertext)
    print("Decrypted message:", decrypted_message)